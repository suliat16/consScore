#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Tue Jun 26 09:45:57 2018

@author: suliat16
"""

import os
import re
import warnings
from consScore import constool
from fractions import Fraction
from biskit import ProfileCollection
import biskit.tools as t
from biskit.exe import Executor
from biskit.errors import BiskitError

class SequenceError(BiskitError):
    pass

class MAFFTError(BiskitError):
    pass

class Rate4SiteError(BiskitError):
    pass


class MAFFT(Executor):

    """
      Calls the Mafft program to build an alignment of protein sequences
       Args:
           file: The absolute file path to the collection of protein sequences
       Returns:
           A string detailing the path to the folder containing the alignment file. The
           alignment is output in the current working directory.

    Note- the alignment is given in clustal format, and the alignment method that maff uses is automatically chosen
    based on the size of the file to be aligned
    """

    def __init__(self, file):
        filename = os.path.basename(file)
        self.filename = filename.split('.')[0]

        super().__init__(name="mafft", args=" --auto --clustalout {0}".format(file), f_out='%s.aln' % (self.filename))
        self.cwd = os.getcwd()
        self.has_run = False
        self.returncode = None


    def run( self, inp_mirror=None):
        """
        Calls the executor run method if it is a first run, otherwise just calls
        the post execution methods on the cached files
        """
        if self.has_run:
            self.finish()
            return self.result
        else:
            return super().run()

    def finish(self):
        """
        Overwrites Executor method. Called when the program is done executing.
        """
        super().finish()
        self.has_run = True
        self.result = self.cwd + os.sep + '%s.aln' % (self.filename)

    def isfailed(self):
        """
        Overwrites Executor method. Return True if the external program has finished
        successfully, False otherwise
        """
        if self.returncode == 0:
            ret = False
        else:
            ret = True
        return ret

    def fail(self):
        """"""
        s = 'MAFFT failed. Please check the program output in the ' + \
            'field `output` of this MAFFT instance, (eg. `print x.output`)!'
        self.log.add(s)
        raise MAFFTError(s)

def build_alignment(file):
    """
       Calls the Mafft program to build an alignment of protein sequences in fasta format
       Args:
           file: The absolute file path to the collection of protein sequences
       Returns:
           A string detailing the path to the folder containing the alignment file. The
           alignment is output in the current working directory.
       """
    filename = os.path.basename(file)
    filename = filename.split('.')[0]

    aln = Executor(name="mafft", args=" --auto {0}".format(file), f_out='%s.aln' % (filename))
    directory = os.getcwd() + os.sep + '%s.aln' % (filename)
    aln.run()
    return directory

def clean_alignment(path, cache):
    """
    Deletes the files generated by Mafft when called using build_alignment
    Args:
        path (str): The file path to the alignment file
        cache (Boolean): If true, the alignment file is kept. If false, the alignment
        file is also deleted
    """
    filename = os.path.basename(path)
    filename = str(filename.split('.')[0])

    if not cache:
        t.tryRemove(os.getcwd() + os.sep + '%s.aln' % (filename))
    t.tryRemove(os.getcwd() + os.sep + '%s.dnd' % (filename))


class Rate4Site(Executor):

    """
    Wraps the Rate4Site program. Calling run() executes the program, which creates
    a folder containing the rate4site output information and the tree, and returns
    a dictionary that maps the data onto each amino acid, which by default is the
    conservation score.

    Rate4Site is used for academic purposes. Citation:
    Mayrose, I., Graur, D., Ben-Tal, N., and Pupko, T. 2004. Comparison of
    site-specific rate-inference methods: Bayesian methods are superior.Mol Biol
    Evol 21: 1781-1791.
    """

    def __init__(self, msa, profile=True, cache=True, identity=True, score=True, qqint=False, std=False,
                gapped=False, **kw):

        aln_file = os.path.basename(msa)
        self.dir_name = aln_file.split('.')[0]
        super().__init__(name='rate4site', args='-s %s -o %s.res' % (msa, self.dir_name),
                         catch_out=1, **kw)
        self.alpha = 0
        self.cwd = os.getcwd()
        self.score_output = self.cwd + os.sep + '%s.res' % self.dir_name
        self.has_run = False
        self.cache = cache
        self.identity = identity
        self.score = score
        self.qqint = qqint
        self.std = std
        self.gapped = gapped
        self.profile = profile
        self.num_sequences= 0

    def run(self, inp_mirror=None):
        """
        Calls the executor run method if it is a first run, otherwise just calls
        the post execution methods on the cached files
        """
        if self.has_run:
            self.finish()
            return self.result
        else:
            return super().run()

    def finish(self):
        """
        Overwrites Executor method. Called when the program is done executing.
        """
        super().finish()
        self.alpha = get_alpha(self.score_output)
        if self.profile:
            self.result = self.rate2profile(self.score_output)
        else:
            self.result = self.rate2dict(self.score_output)
        self.has_run = True

    def isfailed(self):
        """
        Overwrites Executor method. Return True if the external program has finished
        successfully, False otherwise
        """
        if self.returncode == 0:
            ret = False
        else:
            ret = True
        return ret

    def fail(self):
        """
        Overwrites Executor method. Called if external program has failed
        """
        s = 'Rate4Site failed. Please check the program output in the ' +\
            'field `output` of this Rate4Site instance, (eg. `print x.output`)!'
        self.log.add(s)
        raise Rate4SiteError(s)

    def cleanup(self):
        """
        Overwrites Executor method. Cleans up files created during program execution.
        """
        t.tryRemove(self.cwd + os.sep + 'r4s.res')
        t.tryRemove(self.cwd + os.sep + 'r4sOrig.res')
        super().cleanup()
        if not self.cache:
            self.close()
            t.tryRemove(self.cwd + os.sep + self.dir_name, tree=True)

    def close(self):
        """
        Deletes the output files of rate4site- the alignment tree and the score
        sheet.
        """
        t.tryRemove(self.cwd + os.sep + 'TheTree.txt')
        t.tryRemove(self.cwd + os.sep + '%s.res' % (self.dir_name))
        t.tryRemove(self.tempdir, tree=True)
        self.has_run = False

    def rate2dict(self,r4s):
        """
        Take the output from rate4site and convert it into a numpy array, mapping
        each conservation score onto its corresponding amino acid.

        Args:
            r4s (str): The absolute filepath to the output file from the Rate4Site program, version 2.01
            If the following parameters are true, the resulting dictionary will contain that information, in the
            order of the arguments
                identity (boolean): The identity of the amino acid (Single letter code) at each position
                score(boolean): The conservation scores. lower value = higher conservation.
                qqint(boolean): QQ-INTERVAL, the confidence interval for the rate estimates. The default interval is 25-75 percentiles
                std(boolean): The standard deviation of hte posterior rate distribution
                gapped(boolean): MSA DATA, the number of aligned sequences having an amino acid (non-gapped) from the overall
                    number of sequences at each position
        Returns:
            An array, where the entry at each index contains information about
            the amino acid at that position.
        """
        # The document is parsed by pulling splitting the text from the output file
        # using newlines as delimiters, and grabbing only the lines that do not start
        # with a # symbol. Whats left are the rows of the table, where each row contains
        # information about an amino acid. The rows are then split up depending on
        # what information it carries.

        try:
            if os.path.isfile(r4s):
                with open(r4s, 'r') as file:
                    contents = file.read()
                residues = extract_resi(contents)
                r2dict = {}
                i = 0
                for r in residues:
                    r2mat = []
                    aa_data = re.split(r'[\]\[\s,]', r)
                    aa_data = list(filter(lambda x: x is not '', aa_data))
                    if self.identity:
                        amino = aa_data[1]
                        r2mat.append(amino)
                    if self.score:
                        conse = float(aa_data[2])
                        r2mat.append(conse)
                    if self.qqint:
                        intqq = (float(aa_data[3]), float(aa_data[4]))
                        r2mat.append(intqq)
                    if self.std:
                        stdev = float(aa_data[5])
                        r2mat.append(stdev)
                    if self.gapped:
                        align = aa_data[6]
                        r2mat.append(align)
                    r2mat = tuple(r2mat)
                    r2dict[i] = r2mat
                    i += 1
                return r2dict
            else:
                raise FileNotFoundError
        finally:
            warnings.warn("This method is especially susceptible to changes in the format of the output file", Warning)

    def rate2profile(self, r4s):
        """"""
        # Note: looping over the output dictionary feels inefficient. Dw, I can copy the above and output directly into a PC
        try:
            if os.path.isfile(r4s):
                with open(r4s, 'r') as file:
                    contents = file.read()
                residues = extract_resi(contents)
                r2mat = ProfileCollection()
                identity = []
                score = []
                qqint = []
                std = []
                gapped = []

                for r in residues:
                    aa_data = re.split(r'[\]\[\s,]', r)
                    aa_data = list(filter(lambda x: x is not '', aa_data))
                    if self.identity:
                        amino = aa_data[1]
                        identity.append(amino)
                    if self.score:
                        conse = float(aa_data[2])
                        score.append(conse)
                    if self.qqint:
                        intqq = [float(aa_data[3]), float(aa_data[4])]
                        qqint.append(intqq)
                    if self.std:
                        stdev = float(aa_data[5])
                        std.append(stdev)
                    if self.gapped:
                        align = Fraction(aa_data[6])
                        self.num_sequences = align.denominator
                        percent = align.numerator / align.denominator
                        gapped.append(percent)

                if self.identity:
                    r2mat.set('Amino Acid', identity, asarray=2)
                if self.score:
                    r2mat.set('Conservation Score', score, asarray=2)
                if self.qqint:
                    r2mat.set('QQ interval', qqint, asarray=2)
                if self.std:
                    r2mat.set('Standard Deviation', std, asarray=2)
                if self.gapped:
                    r2mat.set('Gapped', gapped)
                return r2mat
            else:
                raise FileNotFoundError
        finally:
            warnings.warn("This method is especially susceptible to changes in the format of the output file", Warning)

def get_alpha(r4s):
    """
    Get the alpha parameter of the conservation scores, as defined by rate4site
    Args:
        r4s (file): The absolute file path to the alignment file
    Returns:
        The alpha parameter of the conservation score.
    """
    try:
        if os.path.isfile(r4s):
            with open(r4s, 'r') as f:
                contents = f.read()
            splitted = contents.split(os.linesep)
            for s in splitted:
                if re.search('alpha parameter', s):
                    parameter = constool.get_num(s)
                    return parameter[0]
            raise Rate4SiteError('File format is not supported')
        else:
            raise FileNotFoundError
    except IndexError:
        raise Rate4SiteError('File format is not supported')
    finally:
        warnings.warn("This method is especially susceptible to changes in the format of \
        the output file", Warning)

def extract_resi(string):
    """
    Grabs the lines of the table that correspond to amino acid data, and puts
    them in a list.
    Args:
        string(str): The contents of the rate4site file
    Returns:
        The rows of the amino acid table as a list of strings.
    """
    splitted = string.split(os.linesep)
    residues = []
    for s in splitted:
        #Remove comments and empty lines
        if s is not '' and not s.startswith('#'):
            #Remove comments
            residues.append(s)
    return residues
